/*!
*******************************************************************************
\file be.h
\author (С) НИИ ППМИ, Олег Соловей
\date 2010
\version 1.0

Описание алгоритмов широковещательного шифрования библиотеки bee2.
*******************************************************************************
*/

#if !defined(__BEE2_BE_H)
#define __BEE2_BE_H

#include "bee2/defs.h"
#include "bee2/core/err.h"
#include "bee2/math/sd.h"

// определение размера в байтах буфера для хранения одного индекса множества-покрытия
#define BE_SIZE_P(h) ((u32) (h/8 + 1))
// определение размера в байтах буфера для хранения количества элементов множества-покрытия
#define BE_SIZE_D(h) ((u32) ((h+1)/8 + 1))
// определение максимального количества всех пар индексов множества-покрытия
#define BE_COUNT_COVER(r) ((u32) (r * 2 - 1))
// определение максимального размера в байтах буфера для всех пар индексов множества-покрытия
#define BE_SIZE_COVER(r, h) ((u32) (r * 2 - 1) * (h/8 + 1))

/*
    Структуры для алгоритмов 
*/
typedef struct tag_beUserKey{
    u32    a;
    u32    b;
    u8    key[32]; 
} beUserKey;


#ifdef __cplusplus
extern "C" {
#endif

/*
Функция на основании ключа центра передачи S генерирует ключи всех пользователей 
(реализует шаги 1-4 алгоритма формирования  ключей пользователей) и сохраняет 
их по указателю pAKeys. При этом количество всех ключей записывается по указателю pCount. 
В случае, если pAKeys == NULL функция не выполняет алгоритм, а возвращает в pCount 
количество всех ключей.
*/
err_t beGenUsersKeys(
    u8 h, /*[in] Параметр, определяющий количество пользователей n=2^h в системе */
    u16 m, /*[in] Размер каждого из ключей в системе (в битах): 128, 192 или 256*/
    u8 *S, /*[in] Ключ центра передачи данных (размера m битов)*/
    beUserKey *pAKeys, /* [out] Массив всех ключей пользователей */
    u32 *   pCount  /* [out] Количество всех ключей пользователей */
);

/*
Функция на основании номера пользователя u выбирает из массива ключей всех 
пользователей pAKeys ключи для пользователя u (реализует шаг 5 алгоритма 
формирования ключей пользователей) и сохраняет их по указателю pUKeys. 
При этом количество ключей пользователя записывается по указателю pCount. 
В случае, если pUKeys = NULL функция не выполняет алгоритм, а возвращает 
в pCount количество ключей для пользователя (при этом pAKeys может быть NULL). 
Ключи для массива pAKeys должны быть сформированы с помощью функции beGenUsersKeys.
*/
err_t beGetUserKeys(
    u8 h, /*[in] Параметр, определяющий количество пользователей n=2^h в системе */
    u16 m, /*[in] Размер каждого из ключей в системе (в битах): 128, 192 или 256*/
    u32 u, /*[in] Номер пользователя (от 1 до 2^h) */
    beUserKey *pAKeys, /* [in] Массив всех ключей пользователей */
    beUserKey *pUKeys, /* [out] Массив ключей пользователя u */
    u32 *pCount /* [out] Количество ключей пользователя u */
);

/*
Функция на основании множества запрещенных пользователей R формирует сообщение Х_1 
протокола широковещательного шифрования (pBX) и записывает по адресу pSize размер 
сформированного сообщения (соответствует шагам 1.2, 1.3 протокола). 
Если pBX = NULL функция не формирует сообщение, а возвращает в pSize максимально 
возможный размер сообщения pBX в байтах (для заданного множества запрещенных 
пользователей R).
В массиве R последовательные номера битов соответствуют последовательным номерам 
пользователей, при этом самый младший бит соответствует пользователю c номером 1. 
Если бит установлен в 1, то пользователь является запрещенным. 
Все пользователи не могут быть запрещенными.
*/
u32    beFormBMsgX(
    u8 h, /*[in] Параметр, определяющий количество пользователей n=2^h в системе */
    u8 *R, /*[in] Указатель на массив запрещенных пользователей размера 2^{h-3} байтов */
    u32 *r, /* [out] Количество запрещенных пользователей */
    u8 *pBX, /*[out] Сообщение Х_1 протокола (начало сообщения X)*/
    u32 *pSize /*[out] Размер сформированного сообщения pBX в байтах */
);


/*
Функция на основании сообщения Х_1 (pBX), ключа центра передачи данных S, 
сеансового ключа за-щиты данных K протокола широковещательного шифрования формирует сообщение, 
являющееся конкатанацией сообщений Х_2, X_3, …,X_{d+2} протокола (окончание сообщения X) и 
записывает по адресу pSize размер сформированного сообщения (соответствует шагу 1.3 протокола). 
Если pEX = NULL функция не формирует сообщение, а возвращает в pSize максимально возможный размер 
сообщения pEX в байтах. При этом размер определяется на основании pBX или R (если pBX = NULL). 
При задании pBX размер определяется точно, а если pBX = NULL, то определяется максимально 
возможный размер.
Сообщение, которое передается в pBX должно быть сформировано с помощью функции beFormBMsgX.
*/
u32    beFormEMsgX(
    u8 h, /*[in] Параметр, определяющий количество пользователей n=2^h в системе */
    u16 m, /*[in] Размер каждого из ключей в системе (в битах): 128, 192 или 256*/
    u8 *S, /*[in] Ключ центра передачи данных (размера m битов)*/
    u8 *K, /* [in] Указатель на сеансовый ключ защиты данных (размера m битов) */
    u32 r, /* [in] Количество запрещенных пользователей */
    u8 *pBX, /* [in] Сообщение Х_1 протокола (начало сообщения X)*/
    u8 *pEX, /* [out] Сообщение, являющееся конкатанацией сообщений Х_2, X_3, …, X_{d+2}*/
    u32 *pSize /* [out] Размер сформированного сообщения pEX в байтах */
);

/*
Функция на основании сообщения M и сеансового ключа защиты данных K протокола 
широковещательного шифрования формирует сообщение Y (соответствует шагу 1.5 протокола), 
и записывает по адресу pSizeAY размер сформированного сообщения. 
Если pAY = NULL функция не формирует сообщение, а возвращает в pSizeAY требуемый 
размер буфера pAY в байтах (размер определяется на основании параметра SizeM).
*/
u32    beFormAMsgY(
    u32 m, /* [in] Размер каждого из ключей в системе (в битах): 128, 192 или 256*/
    u8 *K, /* [in] Указатель на сеансовый ключ защиты данных (размера m битов) */
    u8 *T, /* [in] Указатель на синхропосылку */
    u8 *M, /* [in] Данные, подлежащие широковещательному шифрованию */
    u32 SizeM, /* [in] Размер данных, подлежащих широковещательному шифрованию, в байтах*/
    u8 *pAY, /* [out] Сообщение Y протокола */
    u32 *pSizeAY /* [out] Размер сформированного сообщения Y (pАY) */
);

/*
Функция производит для пользователя u разбор сообщения Х_1 (pBX) протокола и формирует на основании 
массива ключей пользователей pUKeys ключ снятия защиты pDKey и определяет номер e, 
который будет использоваться при расшифровании сеансового ключа (соответствует шагу 2.1 протокола). 
Дополнительно функция извлекает из сообщения Х_1 параметр d. 
Если пользователь u является запрещенным, то функция возвращает код ошибки ERR_REVOKED.
*/
err_t beAnalyzBMsgX(
    u8 h, /*[in] Параметр, определяющий количество пользователей n=2^h в системе */
    u16 m, /*[in] Размер каждого из ключей в системе (в битах): 128, 192 или 256*/
    u32 u, /*[in] Номер пользователя (от 1 до 2^h) */
    beUserKey *pUKeys,  /* [in] Массив ключей пользователя u */
    u8 *pBX, /* [in] Сообщение Х_1 протокола (начало сообщения X)*/
    u32 SizeBX, /* [in] Длина сообщения pBX в байтах */
    u32 *d, /* [out] Параметр d протокола (определяет количество ключей установки защиты)*/
    u32 *pE, /* [out] Номер e ключа снятия защиты */
    u8 *pDKey /* [out] Ключ снятия защиты */
);

/*
Функция на основании номера ключа снятия защиты (E) и ключа снятия защиты (pDkey) производит разбор 
сообщения, являющегося конкатанацией сообщений Х2, X3, …, Xd+2 протокола (окончание сообщения X), 
расшифровывает и возвращает сеансовый ключ K. 
Дополнительно функция возвращает имитовставку сообщения X соответствует сообщению Х2). 
*/
err_t beAnalyzEMsgX(
    u16 m, /*[in] Размер каждого из ключей в системе (в битах): 128, 192 или 256*/
    u8 *pEX, /* [in] Сообщение, являющееся конкатанацией сообщений Х_2, X_3, …, X_{d+2}*/
    u32 SizeEX, /* [in] Длина сообщения pEX */
    u32 d, /* [in] Параметр d протокола (определяет количество ключей установки защиты)*/
    u32 E, /* [in] Номер e ключа снятия защиты */
    u8 *pDKey, /* [in] Ключ снятия защиты (размера m битов) */
    u8 *pK, /* [out] Cеансовый ключ защиты данных (размера m битов) */
    u8 *pImito /* [out] Имитовставка от сообщения pBX */
);

/*
Функция проверяет на основании сеансового ключа K и имитовставки (Imito) 
целостность сообщения Х_1 pBX).
Cоответствует шагам 2.2, 2.3 протокола
Если целостность сообщения X1 не нарушена, то возвращается код ошибки ERR_OK, 
иначе функция возвращает код ошибки ERR_BAD_MAC.
*/
err_t beCheckMsgX(
    u8 h, /*[in] Параметр, определяющий количество пользователей n=2^h в системе */
    u16 m, /*[in] Размер каждого из ключей в системе (в битах): 128, 192 или 256*/
    u8 *pBX, /* [in] Сообщение Х_1 протокола (начало сообщения X)*/
    u32 SizeBX, /* [in] Длина сообщения pBX в байтах */
    u8 *pK, /* [in] Cеансовый ключ защиты данных (размера m битов) */
    u8 *pImito /* [in] Имитовставка от сообщения pBX */
);

/*
Функция на основании сеансового ключа защиты данных K извлекает из сообщения Y, 
расшифровывает и проверяет имитовставку исходных данных, 
т.е. данных M, которые соответствуют сообщению Y2 (соответствует шагам 2.4 - 2.6 протокола). 
Если целостность данных не нарушена, то возвращается код ошибки ERR_OK, 
иначе функция возвращает код ошибки ERR_BAD_MAC. 
Если M=NULL функция возвращает требуемый размер буфера M в pSizeM.
*/
err_t beAnalyzAMsgY(
    u16 m, /*[in] Размер каждого из ключей в системе (в битах): 128, 192 или 256*/
    u8 *pK, /* [in] Cеансовый ключ защиты данных (размера m битов) */
    u8 *pAY, /* [in] Сообщение Y протокола */
    u32 SizeAY, /* [in] Длина сообщения Y протокола */
    u8 *M, /* [out] Данные, подлежащие широковещательному шифрованию */
    u32 *pSizeM /* [out] Длина данных, подлежащие широковещательному шифрованию (М)*/
);

#ifdef __cplusplus
}
#endif

#endif //__BEE2_BE_H