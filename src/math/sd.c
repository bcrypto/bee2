/*****************************************************************************
 Notices:    Copyright (c) 2010 APMI
 Author:    Соловей Олег
*****************************************************************************/

#include "bee2/math/sd.h"
#include "bee2/core/mem.h"


/****************************************************************************
Вес Хэмминга байта
*****************************************************************************/
const u8 weight[256] = {
        0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
        4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8};

/****************************************************************************
Номер первого значащего бита в байте
*****************************************************************************/
const u8 firstleave[256] = {
        8, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 
        5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 
        6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 
        5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 
        7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 
        5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 
        6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 
        5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0};

/****************************************************************************
Номер последнего значащего бита в байте
*****************************************************************************/
const u8 lastleave[256] = {
        8, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7};
        

/*****************************************************************************
Определение глубины вершины (т.е. длины пути из корня в данную вершину).
*****************************************************************************/
u8 beGetDepth (u32 v)
{
    if (v < 0x00000100)
        return lastleave[v];
    else if (v < 0x00010000)
        return (lastleave[v >> 8] + 8);
    else if (v < 0x01000000)
        return (lastleave[v >> 16] + 16);
    else 
        return (lastleave[v >> 24] + 24);
}

/*****************************************************************************
Определение ближайшего общего предка (a <= b).
*****************************************************************************/
u32 beGetAncestor (u32 a, u32 b)
{
    b >>= (beGetDepth(b) - beGetDepth(a));
    while (a != b)
    {
        a >>= 1; b >>= 1;
    }
    return a;
}


/*****************************************************************************
Проверка того, что вершина b является потомком вершины a (a <= b).
*****************************************************************************/
bool_t beIsDescendant (u32 a, u32 b)
{
    while (b > a)
    {
        b >>= 1;
    }
    return (b == a);
}

/*****************************************************************************
Определение весса Хэмминга буфера (количества листьев), а также номеров первого
и последнего значащих битов в буфере.
*****************************************************************************/
u32 beGetCountLeaves (u8 *pBuff, u32 len, u32 *first, u32 *last)
{
    u32    i, l = 0, w = 0;
    bool_t    b = FALSE;
    u8    n;

    *first = 0;
    for (i = 0; i < len; i++) 
    {
        n = pBuff[i];
        if (n) /* байт отличен от нуля ?*/
        {
            w += weight[n]; /* подсчитаем вес Хэмминга*/
            l = i * 8 + lastleave[n]; /* запомним номер последнего значащего бита */
            if (!b) 
            {/* установим номер первого значащего бита */
                *first = i * 8 + firstleave[n];
                b = TRUE;
            }
        }
    }
    *last = l; /* установим номер последнего значащего бита */
    return w;
}

/*****************************************************************************
Нахождения <<первого>> листа в дереве T (дерево может быть и неполным) высоты h 
начиная с вершины  с номером a и заканчивая вершиной с номером b
*****************************************************************************/
u32 beGetFirstLeave (u8 *T, u32 a, u32 b)
{
    u32 i, d1 = a/8, d2 = b/8;
    u8  n;

    if (a > b) return 0; /* полагаем, что в этом случае листа нет*/

    if (d1 == d2)
    {/* вершины a и b находятся в одном байте*/
        n = T[d1] & (0xFF << (a % 8)) & (0xFF >> (7 - (b % 8))); /* исключим <<ненужные>> листья*/
        if (n) 
            return (d1 * 8 + firstleave[n]); /* вернем номер вершины */
        else
            return 0; /* листа нет*/
    }
    else 
    {
        n = T[d1] & (0xFF << (a % 8)); /* исключим <<ненужные>> листья*/
        if (n) /* обработаем первый байт*/
            return (d1 * 8 + firstleave[n]); /* вернем номер вершины */
        else if ((d1 + 1) == d2)
        {/* вершины a и b находятся в соседних байтах*/
            n = T[d2] & (0xFF >> (7 - (b % 8))); /* исключим <<ненужные>> листья*/
            if (n) /* обработаем последний байт*/
                return (d2 * 8 + firstleave[n]); /* вернем номер вершины */
            else 
                return 0; /* листа нет*/
        }
        else
        {/* вершины a и b находятся в несоседних байтах*/
            for (i = d1 + 1; i < d2; i++)
            {    /* поищем листья во <<внутренних>> байтах */
                n = T[i];
                if (n)
                    return (i * 8 + firstleave[n]); /* вернем номер вершины */
            }
            n = T[d2] & (0xFF >> (7 - (b % 8))); /* исключим <<ненужные>> листья*/
            if (n) /* обработаем последний байт*/
                return (d2 * 8 + firstleave[n]); /* вернем номер вершины */
            else 
                return 0; /* листа нет*/
        }
    }
}
/*****************************************************************************
Удаление в дереве T (дерево может быть и неполным) всех листьев,
которые являются предками вершины u. 
*****************************************************************************/
u32 beDelLeaves (u8 h, u8 *T, u32 u)
{
    u32 d1, d2, a, b;
    u8  i, m;

    m = beGetDepth(u);
    if (m == h) 
        return ERR_OK;
    if (m > h) 
        return ERR_INVALID_PARAMETER;
    m = h - m;  a = b = u;
    for (i = 0; i < m; i++) 
    {/* цикл по уровням */
        a = a << 1; b = (b << 1) + 1;
        d1 = a/8, d2 = b/8;
        if (d1 == d2) /* вершины a и b находятся в одном байте?*/
            T[d1] &= (((0xFF << (a % 8)) & (0xFF >> (7 - (b % 8)))) ^ 0xFF);
        else 
        {
            T[d1] &= ((0xFF << (a % 8)) ^ 0xFF);
            if ((d1 + 1) == d2) /* вершины a и b находятся в соседних байтах?*/
                T[d2] &= ((0xFF >> (7 - (b % 8))) ^ 0xFF); 
            else
            {
                memSet(T + d1 + 1, 0, d2 - d1 - 1);
                T[d2] &= ((0xFF >> (7 - (b % 8))) ^ 0xFF); 
            }
        }
    }
    T[u/8] |= (0x01 << (u % 8)); /* установили лист */
    return ERR_OK;
}


/***************************************************************************
 Построение множества разрешенных листьев по вершине дерева a, которая 
 не является листом, и вершине b, которая является предком a.
***************************************************************************/
err_t beSetLegalLeaves(u8 h, u8 *R, u32 a, u32 b)
{
    u32 n, m, c, d, e, f, i, sc, sd, se, sf;
    
    /* проверим параметры на корректность */
    if ((h < 3) || (h > BE_MAX_HEIGHT)) 
        return ERR_INVALID_PARAMETER;
    if (R == NULL) 
        return ERR_INVALID_PARAMETER;

    if ((a == 0) && (b == 0))
    { /* особый случай - все пользователи являются разрешенными*/
        memSet(R, 0xFF, BE_SIZE_LEAVES(h));
        return ERR_OK;
    }

    /* проверим параметры на корректность */
    if (a > b) 
        return ERR_INVALID_PARAMETER;
    if ((a == 0) || (a > ((u32)((1 << h) - 1)))) 
        return ERR_INVALID_PARAMETER;
    if ((b == 0) || (b > BE_COUNT_VERTEX(h))) 
        return ERR_INVALID_PARAMETER;
    if (!beIsDescendant(a, b)) 
        return ERR_INVALID_PARAMETER;

    n = beGetDepth(a); m = beGetDepth(b); 
    if (n == m) 
        return ERR_INVALID_PARAMETER; /* вершины находятся на одном уровне*/

    m = m - n; n = h - n;
    c = f = a; d = e = b;
    for (i = 0; i < n; i++)
    {
        c = c << 1; f = (f << 1) + 1;    
        if (i >= m)
        {
            d = d << 1; e = (e << 1) + 1;    
        }
    }
    c = c - (1 << h); d = d - (1 << h); 
    e = e - (1 << h); f = f - (1 << h); 
    if (c == d)
    {    /* установим все биты, начиная от e+1 и до f */
        e++; se = e/8; sf = f/8;
        if (se == sf) /* вершины e и f находятся в одном байте? */
            R[se] |= ((0xFF << (e % 8)) & (0xFF >> (7 - (f % 8))));
        else         
        {
            R[se] |= (0xFF << (e % 8));
            if ((se + 1) == sf) /* вершины e и f находятся в соседних байтах?*/
                R[sf] |= (0xFF >> (7 - (f % 8))); 
            else
            {/* вершины d и e находятся в несоседних байтах */
                memSet(R + se + 1, 0xFF, sf - se - 1);
                R[sf] |= (0xFF >> (7 - (f % 8))); 
            }
        }
    }
    else if (e == f)
    {    /* установим все биты, начиная от c и до d-1 */
        d--; sc = c/8; sd = d/8;
        if (sc == sd) /* вершины c и f находятся в одном байте? */
            R[sc] |= ((0xFF << (c % 8)) & (0xFF >> (7 - (d % 8))));
        else         
        {
            R[sc] |= (0xFF << (c % 8));
            if ((sc + 1) == sd) /* вершины c и d находятся в соседних байтах? */
                R[sd] |= (0xFF >> (7 - (d % 8))); 
            else
            {/* вершины d и e находятся в несоседних байтах */
                memSet(R + sc + 1, 0xFF, sd - sc - 1);
                R[sd] |= (0xFF >> (7 - (d % 8))); 
            }
        }
    }
    else 
    {   
        /* установим все биты, начиная от c до d-1 и от e+1 до f */
        e++; se = e/8; sf = f/8;
        d--; sc = c/8; sd = d/8;
        
        if (sc == sf)
        {    /* вершины c и f находятся в одном байте: |7  f  e  d  c  0|  */
            R[sc] |= (((0xFF << (c % 8)) & (0xFF >> (7 - (d % 8)))) | 
                ((0xFF << (e % 8)) & (0xFF >> (7 - (f % 8)))));
        }
        else if (sc == se)
        {    /* вершины c и e находятся в одном байте: |7  e  d  c  0| */
            R[sc] |= ((0xFF << (c % 8)) & (0xFF >> (7 - (d % 8)))) |
                (0xFF << (e % 8));
            memSet(R + se + 1, 0xFF, sf - se - 1);
            R[sf] |= (0xFF >> (7 - (f % 8))); 
        }
        else if (sc == sd)
        {    /* вершины c и d находятся в одном байте: |7  d  c  0|     */
            R[sc] |= ((0xFF << (c % 8)) & (0xFF >> (7 - (d % 8))));
            if (se == sf)
            {    /* вершины e и f находятся в одном байте: |7  f  e  0| */
                R[sf] |= ((0xFF << (e % 8)) & (0xFF >> (7 - (f % 8))));
            }
            else
            {    /* вершина f одна: |7  f  0| и вершина е одна: |7  е  0| */
                R[se] |=  (0xFF << (e % 8));
                memSet(R + se + 1, 0xFF, sf - se - 1);
                R[sf] |=  (0xFF >> (7 - (f % 8)));
            }
        }
        else 
        {    /* вершина c одна: |7  c  0| */    
            R[sc] |= (0xFF << (c % 8));
            if (sd == sf)
            {    /* вершины d, e, f находятся в одном байте : |7  f  e  d  0| */    
                R[sf] |=  ((0xFF >> (7 - (d % 8))) | 
                          ((0xFF << (e % 8)) & (0xFF >> (7 - (f % 8)))));
                memSet(R + sc + 1, 0xFF, sd - sc - 1);
            }
            else if (se == sf)
            {    /* вершины e, f находятся в одном байте : |7  f  e 0| */
                R[sd] |= (0xFF >> (7 - (d % 8)));
                R[sf] |= ((0xFF << (e % 8)) & (0xFF >> (7 - (f % 8))));
                memSet(R + sc + 1, 0xFF, sd - sc - 1);
            }
            else
            {  /* вершины f одна : |7  f 0| */
                R[sf] |= (0xFF >> (7 - (f % 8)));
                if (sd == se)    
                {/* вершины d, e находятся в одном байте : |7  e  d 0|     */
                    R[sd] |= ((0xFF >> (7 - (d % 8))) & (0xFF << (e % 8)));
                    memSet(R + sc + 1, 0xFF, sd - sc - 1);
                    memSet(R + se + 1, 0xFF, sf - se - 1);
                }
                else
                { /* вершины e одна: |7  e  0|     и вершина d одна:  |7  d  0| */
                    R[sd] |= (0xFF >> (7 - (d % 8)));
                    R[se] |= (0xFF << (e % 8));
                    memSet(R + sc + 1, 0xFF, sd - sc - 1);
                    memSet(R + se + 1, 0xFF, sf - se - 1);
                }
            }
        }
    }
    return ERR_OK;
}

/******************************************************************************************
Определение того, является ли лист "с" разрешенным для подмножества листьев S_{a,b}
******************************************************************************************/
err_t beCheckLeaf(u8  h,  u32 a,  u32 b,  u32 c)
{
    /* проверим параметры на корректность */
    if ((h < 3) || (h > BE_MAX_HEIGHT)) 
        return ERR_INVALID_PARAMETER;
    if ((c < ((u32)(1 << h))) || (c > BE_COUNT_VERTEX(h))) 
        return ERR_INVALID_PARAMETER;
    if ((a == 0) && (b == 0)) 
        return ERR_OK; /* особый случай */
    if ((a == 0) || (a > ((u32)((1 << h) - 1)))) 
        return ERR_INVALID_PARAMETER;
    if ((b == 0) || (b > BE_COUNT_VERTEX(h)) || (a > b)) 
        return ERR_INVALID_PARAMETER;
    if (!beIsDescendant(a, b)) 
        return ERR_INVALID_PARAMETER;

    /* проверим, что вершина "с" является потомком для "а" и не является потомком для "b" */
    if (beIsDescendant(a, c) && (!beIsDescendant(b, c))) 
        return ERR_OK;
    else 
        return ERR_REVOKED;    
}



/****************************************************************************
Построение множества индексов, определяющих множество-покрытие для 
заданного множества запрещенных листьев.
****************************************************************************/
err_t beCreateIdsCover(u8 h, u32 *r, u8 *R, u32 *d, u8 *C)
{
    u32    s, count, size_leaves, size_tree, size_p, t1, t2, offset = 0;
    u32    i, j, l, k, u, p; /* номера вершин дерева */
    u32    e1, e2, e3; /* инкремент в циклах */
    u8 *pST = NULL; /* указатель на дерево Штейнера */
    bool_t    flag; /* флаг указывающий, что из дерева удалялись вершины*/  
    u32  one = 0x00000001;

    /* проверим параметры на корректность */
    if ((h < 3) || (h > BE_MAX_HEIGHT)) 
        return ERR_INVALID_PARAMETER;
    if ((R == NULL) || (d == NULL) || (C == NULL) || (r == NULL)) 
        return ERR_INVALID_PARAMETER;

    /* подсчитаем кол-во запрещенных пользователей и проверим корректность кол-ва*/
    size_leaves = BE_SIZE_LEAVES(h);
    s = beGetCountLeaves(R, size_leaves, &t1, &t2);
    if (((*r != 0) && (*r != s)) || (s == (u32)(1 << h))) 
        return ERR_INVALID_PARAMETER;

    *r = s;
    size_p = h/8+1;             

    /* особый случай --- все пользователи разрешенные */
    if (s == 0) 
    {
        memSet(C, 0, 2*size_p);
        *d = 1;
        return ERR_OK;
    }
        
    /* выделим память для дерева Штейнера и построи его */
    size_tree = BE_SIZE_TREE(h);
    pST = (u8 *)memAlloc(size_tree);
    if (pST == NULL) 
        return ERR_NOT_ENOUGH_MEMORY;
    memSet(pST, 0 , size_leaves); 
    memcpy(pST + size_leaves, R, size_leaves);

    t1 = t1 + (1 << h); /* устанавливаем номер вершины дерева, с которой будем начинать искать лист */
    t2 = t1 + t2; /* устанавливаем номер вершины дерева, до которой будем искать лист */
    count = 0; /* инициализируем переменную, отвечающую за количество пар индексов*/

    while (s > 1)
    {
        flag = FALSE;
        i = t1 - 1; /* будем начинать с вершины t1*/
        for (e1 = 1; e1 < s; e1++) /* пробегаем все листься кроме последнего*/
        {    
            i = beGetFirstLeave(pST, i + 1, t2); /* находим первый лист */
            j = i; /* будем искать начиная с вершины i+1*/
            for (e2 = e1 + 1; e2 <= s; e2++)
            {
                j = beGetFirstLeave(pST, j + 1, t2);    /* находим второй лист */
                u = beGetAncestor(i, j); /* находим общего предка */
                p = t1 - 1; /* будем искать начиная с вершины t1*/
                for (e3 = 1; e3 <= s; e3++)
                { /* поищем все листья, которые являются потомками u*/
                    p = beGetFirstLeave(pST, p + 1, t2); 
                    if ((p == i) | (p == j)) 
                        continue;
                    /* проверим, является ли p потомком u*/
                    if (p) 
                    {
                        if ((p >> (beGetDepth(p) - beGetDepth(u))) == u) 
                            break;
                    }
                }
                if (e3 > s)  /* нет других листьев кроме i и j?*/
                {    
                    /* добавляем пары индексов, если выполняются услови (согласно алгоритму) */
                    l = u << 1; k = l + 1; /* находим сыновей u*/
                    if ((i >> (beGetDepth(i) - beGetDepth(l))) != l) /* l является предком i?*/
                    {/* меняем местами l и k */
                        l ^= k; k ^= l; l ^= k;
                    }
                    if (l != i)
                    {/* добавим пару индексов в выходной буфер*/
                        count++;
                        memcpy(C + offset, (u8 *) &l, size_p); 
                        offset += size_p;
                        memcpy(C + offset, (u8 *) &i, size_p); 
                        offset += size_p;
                    }
                    if (k != j)
                    {/* добавим пару индексов в выходной буфер*/
                        count++;
                        memcpy(C + offset, (u8 *) &k, size_p); 
                        offset += size_p;
                        memcpy(C + offset, (u8 *) &j, size_p); 
                        offset += size_p;
                    }
                    if (beDelLeaves(h, pST, u) != ERR_OK) /* удаляем всех потомков u */
                    {
                        memFree(pST);
                        return ERR_INTERNAL;
                    } 
                    flag = TRUE; 
                    break; /* выходим с цикла*/
                }
                if (flag) 
                    break; /* выходим с цикла*/
            }
            if (flag) 
                break; /* выходим с цикла*/
        }
        s = beGetCountLeaves(pST, size_tree, &t1, &t2); /* посчитаем запрещенных пользователей */
    }
    if (s == 1) 
    {/* обработаем особый случай*/
        p= beGetFirstLeave(pST, t1, t2); 
        if (p!= 1)
        {
            count++;
            memcpy(C + offset, (u8 *) &one, size_p); 
            offset += size_p;
            memcpy(C + offset, (u8 *) &p, size_p); 
            offset += size_p;
        }
    }
    *d = count;
    free(pST);
    return ERR_OK;
}



